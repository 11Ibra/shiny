% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bookmark-state.R
\name{configureBookmarking}
\alias{configureBookmarking}
\title{Configure bookmarking for the current session}
\usage{
configureBookmarking(eventExpr, type = c("encode", "persist", "disable"),
  exclude = NULL, onBookmark = NULL, onBookmarked = NULL,
  onRestore = NULL, onRestored = NULL,
  session = getDefaultReactiveDomain())
}
\arguments{
\item{eventExpr}{An expression to listen for, similar to
\code{\link{observeEvent}}.}

\item{type}{Either \code{"encode"}, which encodes all of the relevant values
in a URL, \code{"persist"}, which saves to disk, or \code{"disable"}, which
disables any previously-enabled bookmarking.}

\item{exclude}{Input values to exclude from bookmarking.}

\item{onBookmark}{A function to call just before saving state. It will be
passed a \code{\link{ShinySaveState}} object. The \code{values} field of
the object can be manipulated to save extra information, and if the state
is being persisted, the \code{dir} field can be used to save extra
information to files in that directory.}

\item{onBookmarked}{A callback function to invoke after the bookmarking has
been done. The default behavior is to show a modal dialog in the client
browser, with the bookmark URL.}

\item{onRestore}{A function to call when a session is restored. It will be
called after the server function executes, but before all other reactives,
observers and render functions are run. This function will be passed a list
with three items: \code{input}, a named list with input values; \code{dir},
the path to a directory with other persisted content (only if the state was
persisted and not encoded); and \code{values}, extra values that were saved
with the \code{onBookmark} function.}

\item{onRestored}{A function to call after a session is restored. This is
similar to \code{onRestore}, but it will be called after all reactives,
observers, and render functions run, and after results are sent to the
client browser. This makes it appropriate for setup code that must be run
only after the client receives its first update -- for example, sending an
update an input that was dynamically generated. This function will be
passed the same object as \code{onRestore}.}

\item{session}{A Shiny session object.}
}
\description{
There are two types of bookmarking: persisting state, and encoding state. For
persisting state, the state of the application will be saved on disk, and can
be restored with the corresponding state ID. For encoding state, the state of
the application will be encoded in a URL.
}
\details{
For restoring state to work properly, the UI must be a function that takes
one argument, \code{req}. In most Shiny applications, the UI is not a
function; it might have the form \code{fluidPage(....)}. Converting it to a
function is as simple as wrapping it in a function, as in
\code{function(request) \{ fluidPage(....) \}}.

By default, all input values will be bookmarked, except for the values of
actionButtons and passwordInputs. FileInputs will be saved if the state is
persisted, but not if if the state is encoded.

When persisting state, arbitrary values can be saved to disk, by passing a
function as Extra values can be stored, by passing a function as the
\code{onBookmark} argument. That function will be passed a
\code{\link{ShinySaveState}} object. The \code{values} field of the object
can be manipulated to save extra information. Additionally, if the state is
being persisted, and the \code{dir} field of that object can be used to save
extra information to files in that directory.

For persisted state, this is how the persisted state directory is chosen:
\itemize{
  \item If running in a hosting environment such as Shiny Server or Connect,
    the hosting environment will choose the directory.
  \item If running an app in a directory with \code{\link{runApp}()}, the
    persisted states will be saved in a subdirectory of the app called
    shiny_persist.
  \item If running a Shiny app object that is generated from code (not run
    from a directory), the persisted states will be saved in a subdirectory
    of the current working directory called shiny_persist.
}
}
\examples{
## Only run these examples in interactive R sessions
if (interactive()) {

# Basic example with encoded state
ui <- function(request) {
  fluidPage(
    textInput("txt", "Text"),
    checkboxInput("chk", "Checkbox"),
    bookmarkButton("bookmark")
  )
}
server <- function(input, output, session) {
  configureBookmarking(input$bookmark, type = "encode")
}
shinyApp(ui, server)


# Basic example with persisted state
ui <- function(request) {
  fluidPage(
    textInput("txt", "Text"),
    checkboxInput("chk", "Checkbox"),
    bookmarkButton("bookmark")
  )
}
server <- function(input, output, session) {
  configureBookmarking(input$bookmark, type = "persist")
}
shinyApp(ui, server)


# Update browser's location bar automatically when inputs change
ui <- function(request) {
  fluidPage(
    textInput("txt", "Text"),
    checkboxInput("chk", "Checkbox")
  )
}
server <- function(input, output, session) {
  configureBookmarking(reactiveValuesToList(input),
    type = "encode",
    onBookmarked = function(url) {
      updateLocationBar(url)
    }
  )
}
shinyApp(ui, server)


# Save/restore arbitrary values
ui <- function(request) {
  fluidPage(
    textInput("txt", "Text"),
    checkboxInput("chk", "Checkbox"),
    bookmarkButton("bookmark"),
    br(),
    textOutput("lastSaved")
  )
}
server <- function(input, output, session) {
  vals <- reactiveValues(savedTime = NULL)
  output$lastSaved <- renderText({
    if (!is.null(vals$savedTime))
      paste("Last saved at", vals$savedTime)
    else
      ""
  })

  configureBookmarking(input$bookmark,
    type = "encode",
    onBookmark = function(state) {
      vals$savedTime <- as.character(Sys.time())
      # state is a mutable reference object, and we can add arbitrary values
      # to it.
      state$values <- list(
        time = vals$savedTime
      )
    },
    onRestore = function(state) {
      vals$savedTime <- state$values$time
    }
  )
}
shinyApp(ui, server)


# Usable with dynamic UI
ui <- function(request) {
  fluidPage(
    sliderInput("slider", "Slider", 1, 100, 50),
    uiOutput("ui"),
    bookmarkButton("bookmark")
  )
}
server <- function(input, output, session) {
  output$ui <- renderUI({
    textInput("txt", "Text", input$slider)
  })
  configureBookmarking(input$bookmark, type = "encode")
}
shinyApp(ui, server)


# Exclude specific inputs
# The only input that will be saved in this example is chk
ui <- function(request) {
  fluidPage(
    passwordInput("pw", "Password"),   # Passwords are never saved
    sliderInput("slider", "Slider", 1, 100, 50),
    checkboxInput("chk", "Checkbox"),
    bookmarkButton("bookmark")
  )
}
server <- function(input, output, session) {
  configureBookmarking(input$bookmark,
    exclude = "slider",
    type = "encode"
  )
}
shinyApp(ui, server)


# Save/restore uploaded files
ui <- function(request) {
  fluidPage(
    sidebarLayout(
      sidebarPanel(
        fileInput("file1", "Choose CSV File", multiple = TRUE,
          accept = c(
            "text/csv",
            "text/comma-separated-values,text/plain",
            ".csv"
          )
        ),
        tags$hr(),
        checkboxInput("header", "Header", TRUE),
        bookmarkButton("bookmark")
      ),
      mainPanel(
        tableOutput("contents")
      )
    )
  )
}
server <- function(input, output) {
  output$contents <- renderTable({
    inFile <- input$file1
    if (is.null(inFile))
      return(NULL)

    if (nrow(inFile) == 1) {
      read.csv(inFile$datapath, header = input$header)
    } else {
      data.frame(x = "multiple files")
    }
  })

  configureBookmarking(input$bookmark, type = "persist")
}
shinyApp(ui, server)

}
}

